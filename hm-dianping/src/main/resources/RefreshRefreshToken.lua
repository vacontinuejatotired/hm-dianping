---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Ntwitm.
--- DateTime: 2026/2/13 23:16
---
-- KEYS[1]: RefreshToken = "login:token:" .. userId

-- ARGV[1]: oldRefreshToken (请求携带的 RefreshToken)
-- ARGV[2]: newRefreshToken (新生成的 RefreshToken)
-- ARGV[3]: expireSeconds (新 RefreshToken 的过期秒数，例如 30*60 = 1800)
-- ARGV[4]: newToken (新生成的token)
--ARGV[5]: tokenExpireSeconds 外部生成token的指定过期时间

local RefreshTokenKey = KEYS[1]
local tokenKey = KEYS[2]
local versionKey =KEYS[3]
local oldRefreshToken = ARGV[1]
local newRefreshToken = ARGV[2]
local refreshTokenExpireSeconds = tonumber(ARGV[3])
local newToken =ARGV[4]
local tokenExpireSeconds = tonumber(ARGV[5])
local version = tonumber(ARGV[6])
local versionExpireSeconds = tonumber(ARGV[7])

local orginVersion =redis.call('get',versionKey)
if ~orginVersion then
    local result ={
    code = 0,
    message = '该token版本号不存在',
}
    return cjson.encode(result)
end
--比登录时间还早的token不可使用
if tonumber(orginVersion) > version then
    local result
    result.code = 0
    result.message= 'token exists before login'
    return cjson.encode(result)
end
local exists = redis.call('EXISTS', RefreshTokenKey)
if exists == 0 then
    return '{"code":0,"message":"RefreshToken key not found"}'
end
local storedToken = redis.call('GET', RefreshTokenKey)
if storedToken ~= oldRefreshToken then
    return '{"code":0,"message":"RefreshToken mismatch"}'
end
redis.call('DEL', RefreshTokenKey)
redis.call('SET', RefreshTokenKey, newRefreshToken, 'EX', refreshTokenExpireSeconds)
redis.call('DEL',tokenKey)
redis.call('SET',tokenKey,newToken,'EX',tokenExpireSeconds)
redis.call('del',versionKey)
redis.call('SET',versionKey,version,'EX',versionExpireSeconds)
local result = {
    code = 1,
    message = "update all token and version success",
    data = {
        newToken = newToken,
        newRefreshToken = newRefreshToken,
        newVersion = tostring(version)
    }
}
return cjson.encode(result)